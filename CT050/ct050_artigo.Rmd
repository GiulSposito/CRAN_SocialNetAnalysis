---
title: "Análise da Rede de Colaboração de Autores de Pacotes do CRAN usando R"
author: "Giuliano Sposito"
date: "Dezembro de 2017"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
# default behavior of document chunks
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# library setup
library(needs)
needs(data.table)
needs(stringr)   # limpeza e tratamento de strings
needs(tidyverse) # pipeline e manipulacao de dados
needs(igraph)    # manipulacao de grafos
needs(tidygraph) # visualizacoes de redes
needs(ggraph)    # visualizacoes de redes

# default nudge
NUDGE_Y = 0.3

```

Este artigo explora técnicas de *Análise de Redes Sociais* para analisar a rede de colaboração de autores de pacotes de análise para R[^1] publicados no CRAN[^2].

## Conceitos Chaves para Análise de Redes

A *teoria de grafos*, campo da da matemática que estuda as relações entre os objetos de um determinado conjunto, fornece os mecanismos matemáticos que são base para a análise das estruturas da rede. Através do entendimento da estrutura de uma rede é possível ter _insights_ sobre seus padrões, propriedades e indivíduos. 

Um grafo é uma representação matemática de uma rede social, onde os elementos (empresas, pessoas, etc.) são representados por vértices e a relação entre os elementos são representados como arestas entre dois vértices. A ligação (aresta) pode ser direcional ou não direcional. Pode-se associar valores tanto aos nós como arestas.

```{r network}
# Lista de arestas, os números são identificadores dos nós
g_edgelist <- data.frame(
  from = c( 1,1,2,2,3,3,5,5),
  to   = c( 2,3,3,5,4,5,6,7)
) 

# construindo a rede a partir da lista de arestas
g <- g_edgelist %>%
  as.matrix() %>%
  graph.edgelist(directed = FALSE) %>% # usando igraph 
  as_tbl_graph() %>%
  activate("nodes") %>%
  mutate( name = LETTERS[1:7] ) # nomeando os nós

# calculando previamente as métricas
g <- g %>% 
  mutate( degree = centrality_degree(), 
          btwn   = round( centrality_betweenness(),2 ),
          clsn   = round( centrality_closeness(normalized = T),2 ),
          eign   = round( centrality_eigen(scale = F), 2 ))

# fixando o layout previamente para todos os plots terem a mesma disposicao
g_layout <- create_layout(g, layout = "kk")

# plotando o graph
ggraph(g_layout) +
  geom_edge_fan(alpha=0.3) +
  geom_node_point(color="blue",alpha=0.8, size=8) +
  geom_node_text(aes(label=name), color="white") +
  theme_void() +
  ggtitle( "Exemplo de Rede" ) + 
  theme( legend.position = "none" )

```


Há uma série de métricas e propriedades de um grafo que podem fornecer informações relevantes sobre a relação (arestas) entre os indivíduos (vértices) e os próprios indivíduos quando esse representa uma rede social. Iremos explorar algumas propriedades que podem estar ligadas a identificação de capital social, são elas:

* Degree Centrality
* Betweenness Centrality
* Closeness Centrality
* Eigenvector Centrality
* Components
* Density
* Diameter
* Eccentricy


#### Degree Centrality (Grau)

O Grau (_Degree_) é o número de arestas (ou links) que levam para dentro ou para fora de um vértice. Freqüentemente usado como medida de conexão de um nó para outros nós imediatos. Podendo assim representar influencia e/ou popularidade de um nó juntos aos demais. Útil na avaliação de quais nós são fundamentais em relação à disseminação de informações e na capacidade influenciar outros nós na localidade imediata.

Exemplos:
* Quantas pessoas essa pessoa pode alcançar diretamente? 
* Em uma rede de músicos: com quantas pessoas essa pessoa já colaborou/tocou?

```{r degree}
# plot da rede evidenciando o degree
ggraph(g_layout) +
  geom_edge_fan(alpha=0.4) +
  geom_node_point(aes(color = degree), size=8) + 
  geom_node_text(aes(label=name),color="white") +
  geom_node_text(aes(label=degree, color=degree), nudge_y = NUDGE_Y ) +
  theme_graph() +
  # ggtitle( "Degree" ) + 
  theme( legend.position = "none" )

```


#### Betweenness Centrality (Intermediação)

A *Betweenness Centrality* é uma métrica que representa quantos caminhos curtos (_shortest path_) que ligam outros nó da rede, passam pelo nó em questão. Para calcular o valor para um determinado nó **v**, calcule o número de caminhos mais curtos entre os nós **i** e **j** que passam através de **v** e divida por todos os caminhos mais curtos entre **i** e **j**. Repita para todo os nós.

É uma medida importante, pois representa "o quanto" um nó, ou vértice, está dentro dos fluxos de informações possíveis entre os outros nós. Quanto mais alto o valor, maior a importância do nó, como um elo de comunicação entre os demais nós.

Esta métrica também pode ser calculada com respeito a uma aresta, assim estaríamos medindo o quanto um link entre dos nós participa dos caminhos mais curtos entre os nós da rede.

Exemplos: 
* Qual a probabilidade de esta pessoa ser a rota mais direta entre duas pessoas na rede?
* Me uma rede de espiões: quem é o espião pela qual a maioria das informações confidenciais pode fluir?


```{r Betweenness}

# plot da rede evidenciando o betweenness
ggraph(g_layout) +
  geom_edge_fan(alpha=0.4) +
  geom_node_point(aes(color = btwn), size=8) + 
  geom_node_text(aes(label=name),color="white") +
  geom_node_text(aes(label=btwn, color=btwn), nudge_y = NUDGE_Y ) +
  theme_graph() +
  # ggtitle( "Betweenness Centrality" ) + 
  theme( legend.position = "none" )

```


#### Closeness Centrality (Proximidade)

Representa o quão perto um nó está dos demais, pode ser uma medida direta da contagem de arestas ou da soma dos pesos dela. Para obtê-la calcule o comprimento médio de todos os caminhos mais curtos de um nó para todos os outros nós da rede.

É uma medida de _alcance_, mediria por exemplo a velocidade com informações pode alcançar outros nós a partir de um determinado nó inicial, quanto mais próximo um nó dos demais, mais rápido este nó influenciaria outros.

Exemplos:
* Quão rápido essa pessoa pode alcançar todos na rede?
* Em rede de relações sexuais: quão rápido uma DST se espalhará dessa pessoa para o resto da rede?

```{r closeness}
ggraph(g_layout) +
  geom_edge_fan(alpha=0.4) +
  geom_node_point(aes(color = clsn), size=8) + 
  geom_node_text(aes(label=name),color="white") +
  geom_node_text(aes(label=clsn, color=clsn), nudge_y = NUDGE_Y ) +
  theme_graph() +
  # ggtitle( "Closeness" ) + 
  theme( legend.position = "none" )
```


#### Eigenvector Centrality (Autovetor)

A centralidade do _autovetores_ de um nó é proporcional à soma das centralidades de _autovetores de todos os nós diretamente conectados a ele. A métrica é obtida através da fatoração e calculo de autovetores da _matriz de adjacência_[^3] que representa a rede.

Está associado a reputação e um vértice com respeito às suas ligações.

Exemplos:

* Quão bem esta pessoa está conectada a outras pessoas bem conectadas?
* Na rede de citações de artigos: quem é o autor mais citado por outros autores bem citados?

```{r eigenvector}
ggraph(g_layout) +
  geom_edge_fan(alpha=0.4) +
  geom_node_point(aes(color = eign), size=8) + 
  geom_node_text(aes(label=name),color="white") +
  geom_node_text(aes(label=eign, color=eign), nudge_y = NUDGE_Y ) +
  theme_graph() +
  # ggtitle( "Eigenvector" ) + 
  theme( legend.position = "none" )
```


#### Componentes

Um rede pode ter ser segmentada, ou seja, nós formam subredes não conectadas entre si, tais subredes são chamadas de componentes.

```{r components}
# montando uma lista de arestas (os números identificam o vértice)
edgelist <- data.frame(
  from = c(1,1,2,4,2,3,4,5,6,6,7,7,8,8,9,10),
  to   = c(2,3,4,3,5,4,5,1,7,8,9,8,9,10,10,7)
)

# construindo o grafo a partid da lista de aresta
edgelist %>%
  as.matrix() %>%
  graph.edgelist(directed = T) %>%
  as_tbl_graph() %>%
  activate("nodes") %>%
  mutate( name = LETTERS[1:10],
          component = as.factor(group_components())) -> g


ggraph(g, layout="kk") +
  geom_edge_fan(alpha=0.2, arrow = arrow(type="closed", angle=10, length = unit(5,units = "mm") ))+
  geom_node_point(aes(color=component),alpha=0.8, size=8) +
  geom_node_text(aes(label=name), color="white") +
  theme_void() +
  ggtitle( "Components" ) + 
  theme( legend.position = "none" )

```


### Identificando Atores e Padrões

Usando as métricas listadas acima é possível identificar e classificar a atuação e importancia dos atores em uma rede.

Tome-se como exemplo esta rede:

```{r kpnetwork}
# lista de ligacoes
h_edgelist <- data.frame(
  from = c( 0,  1, 1,  2, 2, 3, 3,  3,  4, 5, 5, 5, 8),
  to   = c(10, 10, 2, 10, 3, 4, 5, 10, 10, 6, 7, 8, 9)
) + 1

# construcao da rede
h <- h_edgelist %>%
  as.matrix() %>%
  graph.edgelist(directed = FALSE) %>%
  as_tbl_graph() %>%
  activate("nodes") %>%
  mutate( name = LETTERS[1:11] ) # nomeando nos

# plot
ggraph(h, layout="kk") +
  geom_edge_fan(alpha=0.2) +
  geom_node_point(color="red",alpha=0.9, size=8) +
  geom_node_text(aes(label=name), color="white") +
  theme_void() +
  ggtitle( "Exemplo" ) + 
  theme( legend.position = "none" )
```

Vamos combinar as medidas de centralidade para exibir importantes atores na estrutura.

```{r kpcentralities}
# calculando métricas de centralidade 
h <- h %>%
  activate("nodes") %>%
  mutate (
    degree = as.factor(centrality_degree()),
    btwn = round(centrality_betweenness(), 2),
    clsn = round(centrality_closeness(normalized = T), 2),
    eign = round(centrality_eigen(scale = T), 2),
    clst = as.factor(group_edge_betweenness())) %>% 
  
  # centrality das arestas
  activate("edges") %>%
  mutate( ebtwn = centrality_edge_betweenness() )

ggraph(h, layout="kk") +
  geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn, label=ebtwn), label_size=3) +
  geom_node_point(aes(color=degree, size=clsn),alpha=0.5) +
  geom_node_text(aes(label=name), color="black") +
  geom_node_text(aes(label=eign, color=degree), nudge_y = -NUDGE_Y/2, size=2) +
  theme_void() +
  ggtitle( "Combinando Métricas" ) + 
  scale_color_manual(breaks = c("1", "2","3", "5", "10"),
                     values=c("red","red","lightskyblue","lightskyblue","darkblue"))
```

As várias medidas de centralidade são mostradas acima e são representadas:

* Cor do vértice: Degree Centrality
* Tamanho do vértice: Closeness Centrality
* Número abaixo do vértice: Eiginvector Centrality
* Cor e valor na aresta: Edge Betweenness Centrality

```{r kptable}
h %>% activate("nodes") %>%
  as.tibble() %>%
  select(-clst) %>%
  knitr::kable(caption="Métricas de Centralidade dos Nós")
```

Através das relações entre as centralidades é possível identificar os seguintes aspectos

* Nós mais conectados: **K** com mais conexões seguidas de **D** e **F**;
* A ligação entre a **F** e **D** é a de maior *intermediação*, além disso se removida desconecta o gráfico;
* Além disso, o nó **D** é o mais próximo aos demais e
* O nó **K** é no mais referenciado por nós mas referenciados (maior *eigenvector*), seguido logo por **D**, mais uma vez mostrando a importância do no **D** na estrutura da rede.

#### Gatekeepers & Accessors

Combinando duas métricas de centralidade, autovetores e intermediação, é possível evidênciar dois tipos de atores específicos numa rede. 

* Um ator com **alta intermediação** (*betweenness*) e **baixo autovetor** (*eigenvector*) pode ser um porteiro (_Gatekeeper_) importante para um ator central ou atores importantes.
* Um ator com **baixa intermediação** e **alto autovetor** pode ter acesso exclusivo a atores centrais.

```{r keysplayer}
h %>% activate("nodes") %>% as_tibble() %>% 
  ggplot(aes(x=btwn, y=eign)) + 
  geom_point() + geom_label(aes(label=name)) +
  theme( legend.position = "none" )
```

Observando a distribuição de como *eigenvector* fica em função *betweenness*, é possível observar então que o nó **F** atua como um *Gatekeeper* e o nó **C** como um nó de acesso a ators importantes (*accessor*).


```{r nodetypes}
# key actors type
h <- h %>%
  activate("nodes") %>%
  mutate( type = as.factor(case_when(
    name == "F" ~ "gatekeeper",
    name == "C" ~ "access to central actors",
    TRUE ~ "others"
  )))

# plot
ggraph(h, layout="kk") +
  geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn), label_size=3) +
  geom_node_point(aes(color=type),alpha=0.9, size=8) +
  geom_node_text(aes(label=name), color="white") +
  geom_node_text(aes(label=eign), nudge_y = NUDGE_Y, size=3) +
  theme_void() +
  # ggtitle( "Gatekeeper and Accessor" ) + 
  scale_color_manual(breaks = c("others","gatekeeper","access to central actors"),
                     values=c("red","lightskyblue","darkblue"))

```

Podemos perceber que o nó **C** é o nó que "dá acesso" a nós de auta reputação (*eigenvector*) enquanto o nó **F**, é um nó de relativa baixa reputação que atua de porteiro para os nós de atua relevancia (D, K, E e C).

#### Comunidades (_clusters_)

Muitas redes consistem em módulos que estão densamente conectados, mas que estão escassamente conectados a outros módulos, a esses módulos é dado o nome de *comunidade*. A idéia da detecção de estrutura de comunidade é descobrir "bordas" e detectar arestas quem ligam módulos separados. 

Uma estratégia é calcular a centralidade de betweenness das arestas e ir removendo gradualmente as arestas de maior pontuação, desconectando o gráfico, identificando assim as comunidades.

```{r community}
ggraph(h, layout="kk") +
   geom_edge_fan2(alpha=0.5, aes(edge_colour = ebtwn)) +
  geom_node_point(aes(color=clst),alpha=0.9, size=8) +
  geom_node_text(aes(label=name), color="white") +
  # ggtitle( "Community / Clusters" ) + 
  theme_void() + 
  theme( legend.position = "none" )
```


## Rede de Colaboração de Autores no CRAN

CRAN[^2] é o repositório oficial de pacotes de R, [listando](https://cran.r-project.org/web/packages/available_packages_by_name.html) todos os pacotes produzido e disponibilizado gratuitamente pela comunidade de usuário e programadores. Os pacotes fornece funcionalidades adicionais ou específicas para o R e para serem utilizados devem ser copiados, instalados e carregados. 

Qualquer pessoa pode desenvolver e disponibilizar pacotes, porém é mais comum que os pacotes sejam desenvolvidos por equipes de pesquisa e grupos de programadores dentro de empresas ou universidades ou que sejam um desenvolvimento que segue a dinâmica de software _open source_, quando o código do pacote está público e recebe contribuição de vários desenvolvidores espalhados pelo mundo.

![Autores de um pacote R](./images/xgb_package.png)

O pacote publicado contém uma lista de autores, que contribuíram para construir e publicar o pacote. O objetivo desta análise entender como se organiza a rede de colaboração de autores, para isso usaremos os dados de publicação para construir uma rede, onde cada vértice da rede é um ator e uma aresta identifica um pacote em que dois (ou mais autores) colaboraram juntos.

### Construindo a Rede

```{r crandata, cache=TRUE}

# dados de publicacao de pacotes
pdb <- tools::CRAN_package_db()

# campo de autores dos pacotes
pbaut <- pdb$Author 

# o campo de autores é uma string separada por virgula e contendo outras informações
# é necessario limpar a string e separar os nome dos atuores
aut <- pbaut %>%
  str_replace_all("\\[.*?\\]", "") %>%
  str_replace_all("[\\n\\t]", "") %>%
  str_replace_all("\\<.*?\\>", "") %>%
  str_replace_all("\\(.*?\\)", "") %>% 
  str_replace_all("\\(([^)]+)\\)", "") %>% # remocao 
  str_replace_all("\\[([^]]+)\\]", "") %>% # remocao
  str_replace_all("<([^>]+)>", "") %>% # remocao
  str_replace_all("\n", " ") %>% # remocao
  str_replace_all("[Cc]ontribution.* from|[Cc]ontribution.* by|[Cc]ontributors", " ") %>%
  str_replace_all("\\(|\\)|\\[|\\]", " ") %>% # remocao
  iconv(to = "ASCII//TRANSLIT") %>% # limpeza dos caracters especiais
  str_replace_all("'$|^'", "") %>%  # limpeza
  gsub("([A-Z])([A-Z]{1,})", "\\1\\L\\2", ., perl = TRUE) %>% 
  gsub("\\b([A-Z]{1}) \\b", "\\1\\. ", .) %>%
  map(str_split, ",|;|&| \\. |--|(?<=[a-z])\\.| [Aa]nd | [Ww]ith | [Bb]y ", simplify = TRUE) %>% 
  map(str_replace_all, "[[:space:]]+", " ") %>% 
  map(str_replace_all, " $|^ | \\.", "") %>% 
  map(function(x) x[str_length(x) != 0]) %>%
  set_names(pdb$Package) %>% 
  magrittr::extract(map_lgl(., function(x) length(x) > 1))

# conta autores por pacote
aut_list <- aut %>%
  unlist() %>%
  dplyr::as_data_frame() %>%
  count(value) %>%
  rename(name = value, packages = n)

# transforma a lista "pacote" -> [autores] em uma edge list
edge_list <- aut %>%
  map(combn, m = 2) %>%    # em cada pacote (map) gera uma combinacao do array de autores dois a dois
  do.call("cbind", .) %>%  
  t() %>%
  dplyr::as_data_frame() %>%
  arrange(V1, V2) %>%
  count(V1, V2) 

# controi a rede a partir da lista de arestas
authors_network <- edge_list %>%
  select(V1, V2) %>%
  as.matrix() %>%
  graph.edgelist(directed = FALSE) %>%
  as_tbl_graph() %>%    # wrapper tidygraph para o objeto igraph
  activate("edges") %>% 
  mutate(weight = edge_list$n) %>% # resgata o peso das arestas (# de pacotes)
  activate("nodes") %>%
  left_join(aut_list, by="name") # nomeia os nós com os nomes dos autores

# dados de autores e arestas
total_authors <- authors_network %>% activate("nodes") %>% as.tibble() %>% nrow()
total_edges <- authors_network %>% activate("edges") %>% as.tibble() %>% nrow()

```

### Selecionando Components

A rede construída é composta de `r total_authors` autores que se relacionam através `r total_edges` arestas. Dado a natureza do objeto estudado espera-se que essa rede não seja conecta integralmente, formando então **componentes** de colaboração entre grupos de autores distintos, vamos analisar esse aspécto.

```{r whichcomponents}

# identifica os components
g <- authors_network %>% 
  activate("nodes") %>%  
  mutate(component = as.factor(group_components()))

# tabela components por número de autores
authors.by.components <- g %>% 
  activate("nodes") %>%
  as.tibble() %>%
  group_by(component) %>%
  summarise( authors=n() ) %>%
  arrange( desc(authors) )

# top 10 maiores components
knitr::kable(head(authors.by.components,10), caption = "Maiores componentes (top 10)")
```

Vamos selecionar três destes componentes para caracterizá-los: componentes 30, 33 e 717[^4].

### Comparando os três components

```{r plotcomponents}

sel_components <- c(30,33,717)

# plotando os components
g %>%
  filter( component %in% sel_components ) %>%
  ggraph(layout="auto") +
  geom_edge_fan(alpha=0.2)+
  geom_node_point(aes(color=component),alpha=0.8, size=2) +
  theme_void()

```

Nota-se que os componentes possuem estruturas distintas umas das outras, vamos caracterizá-las com métricas de rede.

```{r compnetworks}

# para cada um do componentes escolhidos
net_metrics <- rbindlist(lapply( sel_components, function(comp){
  # filtra pelo component
  h <- g %>% filter( component == comp )
  # calcula metricas de rede
  res <- data.frame(
    component = comp,
    nodes     = h %>% activate("nodes") %>% as.tibble() %>% nrow(),
    density   = round(graph.density(h, loops = F),4),
    diameter  = diameter(h, directed = F, unconnected = F, weights = NULL),
    eccentricity = max(eccentricity(h, mode="all"))/min(eccentricity(h, mode="all"))
  )
  return(res)
}))

# tabela
knitr::kable(net_metrics)
```


Para cada um dos components calculamos:

* **densidade**: número de arestas da rede dividido pelo número de arestas possíveis;
* **diâmetro**: maior menor caminho (_shortest path_) existente na rede e
* **excentricidade**: aqui definida como o diâmetro dividido pelo menor caminho (_shortest path_).

Nota-se nos valores que as redes de fato são distintas nessas dimensões.

### analise de atores 

```{r actorscentrality}
# calcula centralidades para uma rede
calcNodeMetrics <- function(net, comp){
  net %>%
    activate("nodes") %>%
    filter( component==comp ) %>%
    mutate(
      degree = centrality_degree(),
      btwn = round(centrality_betweenness(), 2),
      clsn = round(centrality_closeness(normalized = T), 2),
      eign = round(centrality_eigen(scale = T), 2),
      clst = as.factor(group_edge_betweenness())
    ) %>%
    activate("edges") %>%
    mutate( ebtwn = centrality_edge_betweenness() ) %>%
    return()
}

# para cada um dos componentes, faz o calculo de centralidades
netMetrics <- lapply(sel_components, function(comp) calcNodeMetrics(g,comp) )
netMetrics <- setNames(netMetrics, sel_components)

```

#### Component 30

```{r comp30, cache=T}
ggraph(netMetrics$`30`, layout="kk") +
  geom_edge_fan2(alpha=0.2, aes(edge_colour = ebtwn)) +
  geom_node_point(aes(color=btwn, size=degree),alpha=0.9) +
  theme_void() %>% +
  theme( legend.position = "none" ) + 
  ggtitle( "Componente 30" )
```

Numa rede totalmente conectada (densidade = 1), todos os nós e arestas tem as mesmas métricas, não é possível selecionar um (ou mais autores) como mais influente ou relação mais importante, a rede é homogênea. Este componente é composto de autores de um só pacote ([rcorpora](https://cran.r-project.org/web/packages/rcorpora/index.html)), cujo os autores não trabalharam com nenhum outro conjunto de autores.

#### Componente 33

```{r comp33plot1}
  ggraph(netMetrics$`33`, layout="kk") +
    geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn)) +
    geom_node_point(aes(color=btwn, size=btwn),alpha=0.9) +
    theme_void() + 
    theme( legend.position = "none" ) + 
    ggtitle( "Componente 33 - Betweenness" )
```

```{r comp33table1}
netMetrics$`33` %>%
  activate("nodes") %>%
  as.tibble() %>%
  arrange( desc(btwn), desc(degree), desc(eign), desc(clsn) ) %>%
  select(-component, -clst) %>%
  head(10) %>%
  knitr::kable(caption = "Autores por Betweeness (10 mais)")

```

A rede do componente 33 já é bem menos acoplada, portanto de menor densidade, é possível visualizar os autores mais bem "relacionados" e os autores que atuam com "pontes" entre os diversos nós na estrutura. Isso é reflexo de quando o autor trabalha em momentos diferentes com outros grupos de autores em pacotes diferentes.


```{r comp33plot2}
ggraph(netMetrics$`33`, layout="kk") +
  geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn)) +
  geom_node_point(aes(color=eign, size=eign),alpha=0.9) +
  theme_void() + 
  theme( legend.position = "none" ) + 
  ggtitle( "Componente 33 - Eigenvector Centrality" )
```

```{r comp33table2}
netMetrics$`33` %>%
  activate("nodes") %>%
  as.tibble() %>%
  arrange( desc(eign), desc(degree), desc(btwn), desc(clsn) ) %>%
  select(-packages, -component, -clst) %>%
  head(10) %>%
  knitr::kable( caption="Autores por Eigenvector (10 mais)")

```

#### Componente 717

O componente 717 tem uma estrutura mais acoplada, com uma densidade de 0,23, intermediária entre a 30 e 33, é possível observar grupos que trabalham juntos e grande autor central conectando os subgrupos.

```{r comp717plot1}
  ggraph(netMetrics$`717`, layout="kk") +
    geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn)) +
    geom_node_point(aes(color=btwn, size=btwn),alpha=0.9) +
    theme_void() + 
    theme( legend.position = "none" ) + 
    ggtitle( "Componente 717 - Betweenness" )
```

```{r comp717table1}
netMetrics$`717` %>%
  activate("nodes") %>%
  as.tibble() %>%
  arrange( desc(btwn), desc(degree), desc(eign), desc(clsn) ) %>%
  select(-component, -clst) %>%
  head(10) %>%
  knitr::kable(caption = "Autores por Betweeness (10 mais)")

```

Podemos observar, de fato, que o autor central [Quanli Wang](https://www.linkedin.com/in/quanli-wang-5645a01b/) trabalhou em 7 pacotes diferente, servindo de pontes para os vários subgrupos presente neste componente. Como ele é o único autor ligando esses subgrupos ele também é o mais bem "referenciado".

```{r comp717plot2}
ggraph(netMetrics$`717`, layout="kk") +
  geom_edge_fan2(alpha=0.4, aes(edge_colour = ebtwn)) +
  geom_node_point(aes(color=eign, size=eign),alpha=0.9) +
  theme_void() + 
  theme( legend.position = "none" ) + 
  ggtitle( "Componente 717 - Eigenvector Centrality" )
```


```{r comp717table2}
netMetrics$`717` %>%
  activate("nodes") %>%
  as.tibble() %>%
  arrange( desc(eign), desc(degree), desc(btwn), desc(clsn) ) %>%
  select(-packages, -component, -clst) %>%
  head(10) %>%
  knitr::kable( caption="Autores por Eigenvector (10 mais)")

```



## Notas e Referências

[^1]: [R](https://www.r-project.org/) é uma linguagem de programação e ambiente para computação e análise estatística, de uso gratuito e que que fornece uma ampla variedade de técnicas  para: modelagem linear e não-linear, testes estatísticos, análise de séries temporais, classificação, agrupamento. 

[^2]: [CRAN](https://cran.r-project.org/) ou _Comprehensive R Archive Network_ é uma rede de FTP e servidores web ao redor do mundo que armazenam versões de código e documentação atualizadas para pacotes e bibliotecas para R. 

[^3]: Matriz de vértices contra vértices cuja as células indica o peso ou a ligação entre os vértices.

[^4]: Escolhi analisando a formato das redes e escolhendo três casos distintos, excluindo o primeiro caso que possue muitos vértices para ser plotado.